import{Clock as e,PerspectiveCamera as t,Scene as i,WebGLRenderer as s,SRGBColorSpace as o,MathUtils as n,Vector2 as r,Color as a,SplineCurve as c,PlaneGeometry as h,ShaderMaterial as d,Mesh as l,OrthographicCamera as p}from"https://cdn.jsdelivr.net/npm/three@0.180.0/+esm";class v{#e;canvas;camera;cameraMinAspect;cameraMaxAspect;cameraFov;maxPixelRatio;minPixelRatio;scene;renderer;#t;size={width:0,height:0,wWidth:0,wHeight:0,ratio:0,pixelRatio:0};render=this.#i;onBeforeRender=()=>{};onAfterRender=()=>{};onAfterResize=()=>{};#s=!1;#o=!1;isDisposed=!1;#n;#r;#a;#c=new e;#h={elapsed:0,delta:0};#d;constructor(e){this.#e={...e},this.#l(),this.#p(),this.#v(),this.resize(),this.#m()}#l(){this.camera=new t,this.cameraFov=this.camera.fov}#p(){this.scene=new i}#v(){this.#e.canvas?this.canvas=this.#e.canvas:this.#e.id?this.canvas=document.getElementById(this.#e.id):console.error("Three: Missing canvas or id parameter"),this.canvas.style.display="block";const e={canvas:this.canvas,powerPreference:"high-performance",...this.#e.rendererOptions??{}};this.renderer=new s(e),this.renderer.outputColorSpace=o}#m(){this.#e.size instanceof Object||(window.addEventListener("resize",this.#u.bind(this)),"parent"===this.#e.size&&(this.#r=new ResizeObserver(this.#u.bind(this)),this.#r.observe(this.canvas.parentNode))),this.#n=new IntersectionObserver(this.#f.bind(this),{root:null,rootMargin:"0px",threshold:0}),this.#n.observe(this.canvas),document.addEventListener("visibilitychange",this.#g.bind(this))}#z(){window.removeEventListener("resize",this.#u.bind(this)),this.#r?.disconnect(),this.#n?.disconnect(),document.removeEventListener("visibilitychange",this.#g.bind(this))}#f(e){this.#s=e[0].isIntersecting,this.#s?this.#w():this.#R()}#g(e){this.#s&&(document.hidden?this.#R():this.#w())}#u(){this.#a&&clearTimeout(this.#a),this.#a=setTimeout(this.resize.bind(this),100)}resize(){let e,t;this.#e.size instanceof Object?(e=this.#e.size.width,t=this.#e.size.height):"parent"===this.#e.size&&this.canvas.parentNode?(e=this.canvas.parentNode.offsetWidth,t=this.canvas.parentNode.offsetHeight):(e=window.innerWidth,t=window.innerHeight),this.size.width=e,this.size.height=t,this.size.ratio=e/t,this.#x(),this.#b(),this.onAfterResize(this.size)}#x(){this.camera.aspect=this.size.width/this.size.height,this.camera.isPerspectiveCamera&&this.cameraFov&&(this.cameraMinAspect&&this.camera.aspect<this.cameraMinAspect?this.#y(this.cameraMinAspect):this.cameraMaxAspect&&this.camera.aspect>this.cameraMaxAspect?this.#y(this.cameraMaxAspect):this.camera.fov=this.cameraFov),this.camera.updateProjectionMatrix(),this.updateWorldSize()}#y(e){const t=Math.tan(n.degToRad(this.cameraFov/2))/(this.camera.aspect/e);this.camera.fov=2*n.radToDeg(Math.atan(t))}updateWorldSize(){if(this.camera.isPerspectiveCamera){const e=this.camera.fov*Math.PI/180;this.size.wHeight=2*Math.tan(e/2)*this.camera.position.length(),this.size.wWidth=this.size.wHeight*this.camera.aspect}else this.camera.isOrthographicCamera&&(this.size.wHeight=this.camera.top-this.camera.bottom,this.size.wWidth=this.camera.right-this.camera.left)}#b(){this.renderer.setSize(this.size.width,this.size.height),this.#t?.setSize(this.size.width,this.size.height);let e=window.devicePixelRatio;this.maxPixelRatio&&e>this.maxPixelRatio?e=this.maxPixelRatio:this.minPixelRatio&&e<this.minPixelRatio&&(e=this.minPixelRatio),this.renderer.setPixelRatio(e),this.size.pixelRatio=e}get postprocessing(){return this.#t}set postprocessing(e){this.#t=e,this.render=e.render.bind(e)}#w(){if(this.#o)return;console.log("Start rendering");const e=()=>{this.#d=requestAnimationFrame(e),this.#h.delta=this.#c.getDelta(),this.#h.elapsed+=this.#h.delta,this.onBeforeRender(this.#h),this.render(),this.onAfterRender(this.#h)};this.#o=!0,this.#c.start(),e()}#R(){this.#o&&(console.log("Stop rendering"),cancelAnimationFrame(this.#d),this.#o=!1,this.#c.stop())}#i(){this.renderer.render(this.scene,this.camera)}clear(){this.scene.traverse(e=>{e.isMesh&&"object"==typeof e.material&&(Object.keys(e.material).forEach(t=>{const i=e.material[t];null!==i&&"object"==typeof i&&"function"==typeof i.dispose&&i.dispose()}),e.material.dispose(),e.geometry.dispose())}),this.scene.clear()}dispose(){console.log("dispose"),this.#z(),this.#R(),this.clear(),this.#t?.dispose(),this.renderer.dispose(),this.isDisposed=!0}}const m=new Map,u=new r;let f=!1;function g(e){const t={position:new r,nPosition:new r,hover:!1,onEnter(){},onMove(){},onClick(){},onLeave(){},...e};return function(e,t){m.has(e)||(m.set(e,t),f||(document.body.addEventListener("pointermove",z),document.body.addEventListener("pointerleave",R),document.body.addEventListener("click",w),f=!0))}(e.domElement,t),t.dispose=()=>{var t;t=e.domElement,m.delete(t),0===m.size&&(document.body.removeEventListener("pointermove",z),document.body.removeEventListener("pointerleave",R),f=!1)},t}function z(e){u.x=e.clientX,u.y=e.clientY;for(const[e,t]of m){const i=e.getBoundingClientRect();b(i)?(x(t,i),t.hover||(t.hover=!0,t.onEnter(t)),t.onMove(t)):t.hover&&(t.hover=!1,t.onLeave(t))}}function w(e){u.x=e.clientX,u.y=e.clientY;for(const[e,t]of m){const i=e.getBoundingClientRect();x(t,i),b(i)&&t.onClick(t)}}function R(){for(const e of m.values())e.hover&&(e.hover=!1,e.onLeave(e))}function x(e,t){const{position:i,nPosition:s}=e;i.x=u.x-t.left,i.y=u.y-t.top,s.x=i.x/t.width*2-1,s.y=-i.y/t.height*2+1}function b(e){const{x:t,y:i}=u,{left:s,top:o,width:n,height:r}=e;return t>=s&&t<=s+n&&i>=o&&i<=o+r}const y={colors:[255,16711680],shaderPoints:16,curvePoints:64,curveLerp1:.5,curveLerp2:.5,radius1:5,radius2:5,sleepRadiusX:50,sleepRadiusY:50,sleepTimeScale1:2,sleepTimeScale2:2};function P(e){const t={...y,...e},i={width:0,height:0},s=function(e){let t,i;return s(e),{setColors:s,getColorAt:function(e,s=new a){const o=Math.max(0,Math.min(1,e))*(t.length-1),n=Math.floor(o),r=i[n];if(n>=t.length-1)return r.clone();const c=o-n,h=i[n+1];return s.r=r.r+c*(h.r-r.r),s.g=r.g+c*(h.g-r.g),s.b=r.b+c*(h.b-r.b),s}};function s(e){t=e,i=[],t.forEach(e=>{const t=new a(e);i.push(t)})}}(t.colors),o=new Array(t.curvePoints).fill(0).map(()=>new r),n=new c(o),p=new r;let v=0,m=0;const u={value:new r},f={value:new r},g={value:new Array(t.shaderPoints).fill(0).map(()=>new r)},z={value:new a(16711935)},w={uRatio:u,uNeonSize:f,uPoints:g,uColor:z};let R,x;return function(){const e=new h(2,2);R=new d({uniforms:w,defines:{SHADER_POINTS:t.shaderPoints},vertexShader:"varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}",fragmentShader:"float sdBezier(vec2 pos,vec2 A,vec2 B,vec2 C){vec2 a=B-A;vec2 b=A-2.0*B+C;vec2 c=a*2.0;vec2 d=A-pos;float kk=1.0/dot(b,b);float kx=kk*dot(a,b);float ky=kk*(2.0*dot(a,a)+dot(d,b))/3.0;float kz=kk*dot(d,a);float res=0.0;float p=ky-kx*kx;float p3=p*p*p;float q=kx*(2.0*kx*kx-3.0*ky)+kz;float h=q*q+4.0*p3;if(h>=0.0){h=sqrt(h);vec2 x=(vec2(h,-h)-q)/2.0;vec2 uv=sign(x)*pow(abs(x),vec2(1.0/3.0));float t=uv.x+uv.y-kx;t=clamp(t,0.0,1.0);vec2 qos=d+(c+b*t)*t;res=length(qos);}else{float z=sqrt(-p);float v=acos(q/(p*z*2.0))/3.0;float m=cos(v);float n=sin(v)*1.732050808;vec3 t=vec3(m+m,-n-m,n-m)*z-kx;t=clamp(t,0.0,1.0);vec2 qos=d+(c+b*t.x)*t.x;float dis=dot(qos,qos);res=dis;qos=d+(c+b*t.y)*t.y;dis=dot(qos,qos);res=min(res,dis);qos=d+(c+b*t.z)*t.z;dis=dot(qos,qos);res=min(res,dis);res=sqrt(res);}return res;}uniform vec2 uRatio;uniform vec2 uNeonSize;uniform vec2 uPoints[SHADER_POINTS];uniform vec3 uColor;varying vec2 vUv;void main(){vec2 pos=(vUv-0.5)*uRatio;vec2 c=(uPoints[0]+uPoints[1])/2.0;vec2 c_prev;float dist=10000.0;for(int i=0;i<SHADER_POINTS-1;i++){c_prev=c;c=(uPoints[i]+uPoints[i+1])/2.0;dist=min(dist,sdBezier(pos,c_prev,uPoints[i],c));}dist=max(0.0,dist);float glow=uNeonSize.y/dist;vec3 col=vec3(0.0);col+=10.0*vec3(smoothstep(uNeonSize.x,0.0,dist));col+=glow*uColor;col=1.0-exp(-col);col=pow(col,vec3(0.5));gl_FragColor=vec4(col,glow);}"}),x=new l(e,R)}(),Object.assign(x,{config:t,update:function({time:e,pointer:r}){if(r.hover)p.x=.5*r.nPosition.x*u.value.x,p.y=.5*r.nPosition.y*u.value.y,m=Math.min(n.points[0].distanceTo(p)/.05,1),v+=.05*(m-v),s.getColorAt(v,z.value);else{const o=e.elapsed*t.sleepTimeScale1,n=e.elapsed*t.sleepTimeScale2,r=Math.cos(o),a=Math.sin(n),c=t.sleepRadiusX/(i.width/u.value.x),h=t.sleepRadiusY/(i.height/u.value.y);p.x=c*r,p.y=h*a,s.getColorAt(.5+.5*Math.cos(e.elapsed),z.value)}n.points[0].lerp(p,t.curveLerp1);for(let e=1;e<t.curvePoints;e++)o[e].lerp(o[e-1],t.curveLerp2);for(let e=0;e<t.shaderPoints;e++)n.getPoint(e/(t.shaderPoints-1),g.value[e])},setColors:function(e){t.colors=e,s.setColors(e)},setSize:function(e,t){i.width=e,i.height=t,b()},updateUniforms:b}),x;function b(){f.value.set(t.radius1,t.radius2),i.width>=i.height?(u.value.set(1,i.height/i.width),f.value.multiplyScalar(1/i.width)):(u.value.set(i.width/i.height,1),f.value.multiplyScalar(1/i.height))}}function C(e,t={}){const i=new v({canvas:e,size:"parent",rendererOptions:{alpha:!0}});i.camera=new p;const s=P(t);s.setSize(i.size.width,i.size.height),i.scene.add(s);const o=g({domElement:i.canvas});return i.onBeforeRender=e=>{s.update({time:e,pointer:o})},i.onAfterResize=e=>{s.setSize(e.width,e.height)},{three:i,neon:s,neonConfig:s.config,setColors:s.setColors,dispose:()=>{o.dispose(),i.dispose()}}}export{C as default};
