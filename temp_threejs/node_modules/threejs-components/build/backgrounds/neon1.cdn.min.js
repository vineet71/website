import{Clock as e,PerspectiveCamera as t,Scene as i,WebGLRenderer as s,SRGBColorSpace as n,MathUtils as o,Color as r,Vector3 as a,Vector2 as h,ShaderMaterial as c,Mesh as l,PlaneGeometry as d,CatmullRomCurve3 as p,OrthographicCamera as m}from"https://cdn.jsdelivr.net/npm/three@0.180.0/+esm";class v{#e;canvas;camera;cameraMinAspect;cameraMaxAspect;cameraFov;maxPixelRatio;minPixelRatio;scene;renderer;#t;size={width:0,height:0,wWidth:0,wHeight:0,ratio:0,pixelRatio:0};render=this.#i;onBeforeRender=()=>{};onAfterRender=()=>{};onAfterResize=()=>{};#s=!1;#n=!1;isDisposed=!1;#o;#r;#a;#h=new e;#c={elapsed:0,delta:0};#l;constructor(e){this.#e={...e},this.#d(),this.#p(),this.#m(),this.resize(),this.#v()}#d(){this.camera=new t,this.cameraFov=this.camera.fov}#p(){this.scene=new i}#m(){this.#e.canvas?this.canvas=this.#e.canvas:this.#e.id?this.canvas=document.getElementById(this.#e.id):console.error("Three: Missing canvas or id parameter"),this.canvas.style.display="block";const e={canvas:this.canvas,powerPreference:"high-performance",...this.#e.rendererOptions??{}};this.renderer=new s(e),this.renderer.outputColorSpace=n}#v(){this.#e.size instanceof Object||(window.addEventListener("resize",this.#g.bind(this)),"parent"===this.#e.size&&(this.#r=new ResizeObserver(this.#g.bind(this)),this.#r.observe(this.canvas.parentNode))),this.#o=new IntersectionObserver(this.#u.bind(this),{root:null,rootMargin:"0px",threshold:0}),this.#o.observe(this.canvas),document.addEventListener("visibilitychange",this.#f.bind(this))}#z(){window.removeEventListener("resize",this.#g.bind(this)),this.#r?.disconnect(),this.#o?.disconnect(),document.removeEventListener("visibilitychange",this.#f.bind(this))}#u(e){this.#s=e[0].isIntersecting,this.#s?this.#w():this.#S()}#f(e){this.#s&&(document.hidden?this.#S():this.#w())}#g(){this.#a&&clearTimeout(this.#a),this.#a=setTimeout(this.resize.bind(this),100)}resize(){let e,t;this.#e.size instanceof Object?(e=this.#e.size.width,t=this.#e.size.height):"parent"===this.#e.size&&this.canvas.parentNode?(e=this.canvas.parentNode.offsetWidth,t=this.canvas.parentNode.offsetHeight):(e=window.innerWidth,t=window.innerHeight),this.size.width=e,this.size.height=t,this.size.ratio=e/t,this.#R(),this.#b(),this.onAfterResize(this.size)}#R(){this.camera.aspect=this.size.width/this.size.height,this.camera.isPerspectiveCamera&&this.cameraFov&&(this.cameraMinAspect&&this.camera.aspect<this.cameraMinAspect?this.#x(this.cameraMinAspect):this.cameraMaxAspect&&this.camera.aspect>this.cameraMaxAspect?this.#x(this.cameraMaxAspect):this.camera.fov=this.cameraFov),this.camera.updateProjectionMatrix(),this.updateWorldSize()}#x(e){const t=Math.tan(o.degToRad(this.cameraFov/2))/(this.camera.aspect/e);this.camera.fov=2*o.radToDeg(Math.atan(t))}updateWorldSize(){if(this.camera.isPerspectiveCamera){const e=this.camera.fov*Math.PI/180;this.size.wHeight=2*Math.tan(e/2)*this.camera.position.length(),this.size.wWidth=this.size.wHeight*this.camera.aspect}else this.camera.isOrthographicCamera&&(this.size.wHeight=this.camera.top-this.camera.bottom,this.size.wWidth=this.camera.right-this.camera.left)}#b(){this.renderer.setSize(this.size.width,this.size.height),this.#t?.setSize(this.size.width,this.size.height);let e=window.devicePixelRatio;this.maxPixelRatio&&e>this.maxPixelRatio?e=this.maxPixelRatio:this.minPixelRatio&&e<this.minPixelRatio&&(e=this.minPixelRatio),this.renderer.setPixelRatio(e),this.size.pixelRatio=e}get postprocessing(){return this.#t}set postprocessing(e){this.#t=e,this.render=e.render.bind(e)}#w(){if(this.#n)return;console.log("Start rendering");const e=()=>{this.#l=requestAnimationFrame(e),this.#c.delta=this.#h.getDelta(),this.#c.elapsed+=this.#c.delta,this.onBeforeRender(this.#c),this.render(),this.onAfterRender(this.#c)};this.#n=!0,this.#h.start(),e()}#S(){this.#n&&(console.log("Stop rendering"),cancelAnimationFrame(this.#l),this.#n=!1,this.#h.stop())}#i(){this.renderer.render(this.scene,this.camera)}clear(){this.scene.traverse(e=>{e.isMesh&&"object"==typeof e.material&&(Object.keys(e.material).forEach(t=>{const i=e.material[t];null!==i&&"object"==typeof i&&"function"==typeof i.dispose&&i.dispose()}),e.material.dispose(),e.geometry.dispose())}),this.scene.clear()}dispose(){console.log("dispose"),this.#z(),this.#S(),this.clear(),this.#t?.dispose(),this.renderer.dispose(),this.isDisposed=!0}}const g={segments:128,colors:["#c7d8e2","#aa3b8c","#3c97ee"],points:[{x:0,y:5,z:20},{x:0,y:0,z:0},{x:0,y:-5,z:20}],closed:!1,offsetScale:{x:10,y:0,z:0},neonSize:5,timeScale:10},{randFloat:u,randFloatSpread:f}=o;function z(e){const i={...g,...e},s=2*i.segments,n={positions:new Array(i.segments).fill().map(()=>new a),colors:new Array(i.segments).fill().map(()=>new r),lengths:new Array(i.segments).fill().map(()=>u(.005,.03)),timeOffsets:new Array(i.segments).fill().map(()=>u(0,1)),velocities:new Array(i.segments).fill().map(()=>u(.5,1))};let o;const m={width:0,height:0},v={value:0},z={value:new h},w={value:i.neonSize},S={value:new Array(s).fill().map(()=>new a)},R={value:n.colors.map(e=>e.clone())},b={uTime:v,uRatio:z,uNeonSize:w,uPoints:S,uColors:R};let x,y,C;const M=new a;return function(){x=new t,x.position.set(0,0,25),x.updateProjectionMatrix(),x.updateMatrixWorld(),y=new c({uniforms:b,defines:{NUM_SEGMENTS:i.segments,NUM_POINTS:s},vertexShader:"varying vec2 vUv;void main(){vUv=uv;gl_Position=vec4(position,1.0);}",fragmentShader:"uniform vec2 uRatio;uniform float uNeonSize;uniform vec3 uPoints[NUM_POINTS];uniform vec3 uColors[NUM_SEGMENTS];varying vec2 vUv;float sdSegment(in vec2 p,in vec2 a,in vec2 b){vec2 pa=p-a,ba=b-a;float h=clamp(dot(pa,ba)/dot(ba,ba),0.0,1.0);return length(pa-ba*h);}void main(){vec2 pos=(vUv-0.5)*uRatio;vec3 col=vec3(0.0);for(int i=0;i<NUM_SEGMENTS;i++){vec3 p1=uPoints[i*2];vec3 p2=uPoints[i*2+1];if((p1.z<-1.0||p1.z>1.0)||(p2.z<-1.0||p2.z>1.0))continue;float dist=sdSegment(pos,p1.xy,p2.xy);float glow=uNeonSize/dist;col+=glow*uColors[i];}gl_FragColor=vec4(col,1.0);}"}),C=new l(new d(2,2),y),o=new p([]),A(i.points),o.closed=i.closed;for(let e=0;e<i.segments;e++)n.positions[e].set(f(1),f(1),f(1));P(i.colors)}(),Object.assign(C,{update:function(e){let t,s;v.value+=e.delta*i.timeScale;for(let e=0;e<i.segments;e++){const r=n.positions[e],a=S.value[2*e],h=S.value[2*e+1];if(t=(n.timeOffsets[e]+v.value*n.velocities[e]*.025)%1,s=o.closed?(t+n.lengths[e])%1:Math.min(1,t+n.lengths[e]),o.getPoint(t,a),o.getPoint(s,h),M.x=r.x*i.offsetScale.x,M.y=r.y*i.offsetScale.y,M.z=r.z*i.offsetScale.z,a.add(M),a.project(x),h.add(M),h.project(x),!o.closed){R.value[e].copy(n.colors[e]).multiplyScalar(Math.sin(Math.PI*t))}}},setColors:P,setCurvePoints:A,setCurveClosed:function(e){o.closed=e},setCurveOffsetScale:function(e){i.offsetScale=e},setNeonSize:function(e){i.neonSize=e,m.width>=m.height?w.value=i.neonSize/m.width:w.value=i.neonSize/m.height},setVelocity:function(e){i.timeScale=e},setSize:function(e,t){m.width=e,m.height=t,e>=t?(z.value.set(1,t/e),w.value=i.neonSize/e):(z.value.set(e/t,1),w.value=i.neonSize/t)}}),C;function P(e){const t=function(e){let t,i;return s(e),{setColors:s,getColorAt:function(e,s=new r){const n=Math.max(0,Math.min(1,e))*(t.length-1),o=Math.floor(n),a=i[o];if(o>=t.length-1)return a.clone();const h=n-o,c=i[o+1];return s.r=a.r+h*(c.r-a.r),s.g=a.g+h*(c.g-a.g),s.b=a.b+h*(c.b-a.b),s}};function s(e){t=e,i=[],t.forEach(e=>{const t=new r(e);i.push(t)})}}(e);for(let e=0;e<i.segments;e++)n.colors[e].copy(t.getColorAt(u(0,1))),R.value[e].copy(n.colors[e]);const s=e.map(e=>{const t=new r;return t.set(e),t.getHexString()});console.log("debugColors",s)}function A(e){o.points=e.map(e=>e.isVector3?e:new a(e.x,e.y,e.z))}}function w(e,t={}){const i=new v({canvas:e,size:"parent"});i.maxPixelRatio=1,i.camera=new m;const s=z(t);return s.setSize(i.size.width,i.size.height),i.scene.add(s),i.onBeforeRender=e=>{s.update(e)},i.onAfterResize=e=>{s.setSize(e.width,e.height)},{three:i,neon:s,setColors:s.setColors,setCurvePoints:s.setCurvePoints,setCurveClosed:s.setCurveClosed,setCurveOffsetScale:s.setCurveOffsetScale,setNeonSize:s.setNeonSize,setVelocity:s.setVelocity,dispose:i.dispose.bind(i)}}export{w as default};
