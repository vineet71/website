import{Clock as e,PerspectiveCamera as t,Scene as i,WebGLRenderer as s,SRGBColorSpace as n,MathUtils as r,Vector2 as o,Object3D as a,BufferGeometry as h,Vector3 as c,Float32BufferAttribute as d,PointsMaterial as l,AdditiveBlending as m,Points as p,TextureLoader as f,Color as v,ACESFilmicToneMapping as g}from"https://cdn.jsdelivr.net/npm/three@0.180.0/+esm";import{EffectComposer as u}from"https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/postprocessing/EffectComposer.js/+esm";import{RenderPass as z}from"https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/postprocessing/RenderPass.js/+esm";import{UnrealBloomPass as w}from"https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/postprocessing/UnrealBloomPass.js/+esm";import{ShaderPass as x}from"https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/postprocessing/ShaderPass.js/+esm";import{OutputPass as b}from"https://cdn.jsdelivr.net/npm/three@0.180.0/examples/jsm/postprocessing/OutputPass.js/+esm";class y{#e;canvas;camera;cameraMinAspect;cameraMaxAspect;cameraFov;maxPixelRatio;minPixelRatio;scene;renderer;#t;size={width:0,height:0,wWidth:0,wHeight:0,ratio:0,pixelRatio:0};render=this.#i;onBeforeRender=()=>{};onAfterRender=()=>{};onAfterResize=()=>{};#s=!1;#n=!1;isDisposed=!1;#r;#o;#a;#h=new e;#c={elapsed:0,delta:0};#d;constructor(e){this.#e={...e},this.#l(),this.#m(),this.#p(),this.resize(),this.#f()}#l(){this.camera=new t,this.cameraFov=this.camera.fov}#m(){this.scene=new i}#p(){this.#e.canvas?this.canvas=this.#e.canvas:this.#e.id?this.canvas=document.getElementById(this.#e.id):console.error("Three: Missing canvas or id parameter"),this.canvas.style.display="block";const e={canvas:this.canvas,powerPreference:"high-performance",...this.#e.rendererOptions??{}};this.renderer=new s(e),this.renderer.outputColorSpace=n}#f(){this.#e.size instanceof Object||(window.addEventListener("resize",this.#v.bind(this)),"parent"===this.#e.size&&(this.#o=new ResizeObserver(this.#v.bind(this)),this.#o.observe(this.canvas.parentNode))),this.#r=new IntersectionObserver(this.#g.bind(this),{root:null,rootMargin:"0px",threshold:0}),this.#r.observe(this.canvas),document.addEventListener("visibilitychange",this.#u.bind(this))}#z(){window.removeEventListener("resize",this.#v.bind(this)),this.#o?.disconnect(),this.#r?.disconnect(),document.removeEventListener("visibilitychange",this.#u.bind(this))}#g(e){this.#s=e[0].isIntersecting,this.#s?this.#w():this.#x()}#u(e){this.#s&&(document.hidden?this.#x():this.#w())}#v(){this.#a&&clearTimeout(this.#a),this.#a=setTimeout(this.resize.bind(this),100)}resize(){let e,t;this.#e.size instanceof Object?(e=this.#e.size.width,t=this.#e.size.height):"parent"===this.#e.size&&this.canvas.parentNode?(e=this.canvas.parentNode.offsetWidth,t=this.canvas.parentNode.offsetHeight):(e=window.innerWidth,t=window.innerHeight),this.size.width=e,this.size.height=t,this.size.ratio=e/t,this.#b(),this.#y(),this.onAfterResize(this.size)}#b(){this.camera.aspect=this.size.width/this.size.height,this.camera.isPerspectiveCamera&&this.cameraFov&&(this.cameraMinAspect&&this.camera.aspect<this.cameraMinAspect?this.#R(this.cameraMinAspect):this.cameraMaxAspect&&this.camera.aspect>this.cameraMaxAspect?this.#R(this.cameraMaxAspect):this.camera.fov=this.cameraFov),this.camera.updateProjectionMatrix(),this.updateWorldSize()}#R(e){const t=Math.tan(r.degToRad(this.cameraFov/2))/(this.camera.aspect/e);this.camera.fov=2*r.radToDeg(Math.atan(t))}updateWorldSize(){if(this.camera.isPerspectiveCamera){const e=this.camera.fov*Math.PI/180;this.size.wHeight=2*Math.tan(e/2)*this.camera.position.length(),this.size.wWidth=this.size.wHeight*this.camera.aspect}else this.camera.isOrthographicCamera&&(this.size.wHeight=this.camera.top-this.camera.bottom,this.size.wWidth=this.camera.right-this.camera.left)}#y(){this.renderer.setSize(this.size.width,this.size.height),this.#t?.setSize(this.size.width,this.size.height);let e=window.devicePixelRatio;this.maxPixelRatio&&e>this.maxPixelRatio?e=this.maxPixelRatio:this.minPixelRatio&&e<this.minPixelRatio&&(e=this.minPixelRatio),this.renderer.setPixelRatio(e),this.size.pixelRatio=e}get postprocessing(){return this.#t}set postprocessing(e){this.#t=e,this.render=e.render.bind(e)}#w(){if(this.#n)return;console.log("Start rendering");const e=()=>{this.#d=requestAnimationFrame(e),this.#c.delta=this.#h.getDelta(),this.#c.elapsed+=this.#c.delta,this.onBeforeRender(this.#c),this.render(),this.onAfterRender(this.#c)};this.#n=!0,this.#h.start(),e()}#x(){this.#n&&(console.log("Stop rendering"),cancelAnimationFrame(this.#d),this.#n=!1,this.#h.stop())}#i(){this.renderer.render(this.scene,this.camera)}clear(){this.scene.traverse(e=>{e.isMesh&&"object"==typeof e.material&&(Object.keys(e.material).forEach(t=>{const i=e.material[t];null!==i&&"object"==typeof i&&"function"==typeof i.dispose&&i.dispose()}),e.material.dispose(),e.geometry.dispose())}),this.scene.clear()}dispose(){console.log("dispose"),this.#z(),this.#x(),this.clear(),this.#t?.dispose(),this.renderer.dispose(),this.isDisposed=!0}}const R=new Map,P=new o;let C=!1;function A(e){const t={position:new o,nPosition:new o,hover:!1,onEnter(){},onMove(){},onClick(){},onLeave(){},...e};return function(e,t){R.has(e)||(R.set(e,t),C||(document.body.addEventListener("pointermove",S),document.body.addEventListener("pointerleave",j),document.body.addEventListener("click",M),C=!0))}(e.domElement,t),t.dispose=()=>{var t;t=e.domElement,R.delete(t),0===R.size&&(document.body.removeEventListener("pointermove",S),document.body.removeEventListener("pointerleave",j),C=!1)},t}function S(e){P.x=e.clientX,P.y=e.clientY;for(const[e,t]of R){const i=e.getBoundingClientRect();L(i)?(F(t,i),t.hover||(t.hover=!0,t.onEnter(t)),t.onMove(t)):t.hover&&(t.hover=!1,t.onLeave(t))}}function M(e){P.x=e.clientX,P.y=e.clientY;for(const[e,t]of R){const i=e.getBoundingClientRect();F(t,i),L(i)&&t.onClick(t)}}function j(){for(const e of R.values())e.hover&&(e.hover=!1,e.onLeave(e))}function F(e,t){const{position:i,nPosition:s}=e;i.x=P.x-t.left,i.y=P.y-t.top,s.x=i.x/t.width*2-1,s.y=-i.y/t.height*2+1}function L(e){const{x:t,y:i}=P,{left:s,top:n,width:r,height:o}=e;return t>=s&&t<=s+r&&i>=n&&i<=n+o}const{randFloat:E,randFloatSpread:O}=r,T={count:5e4,colors:["#a70267","#f10c49","#fb6b41","#f6d86b","#339194"],map:null,timeScale:1};class k extends a{#P;#C;constructor(e,t={}){super(),this.config={...T,...t},this.#P={uTime:{value:0}},this.#A()}#A(){this.geometry=new h;const e=new Float32Array(3*this.config.count),t=new Float32Array(this.config.count),i=new Float32Array(3*this.config.count),s=new c;for(let t=0;t<this.config.count;t++)s.set(O(200),O(200),O(300)),s.toArray(e,3*t);this.geometry.setAttribute("position",new d(e,3)),this.geometry.setAttribute("size2",new d(t,1)),this.geometry.setAttribute("color",new d(i,3)),this.setSizes(1,5),this.setColors(this.config.colors),this.material=new l({blending:m,depthTest:!1,depthWrite:!1,sizeAttenuation:!0,transparent:!0,vertexColors:!0}),this.config.map&&this.loadMap(this.config.map),this.material.onBeforeCompile=e=>{Object.assign(e.uniforms,this.#P),e.vertexShader="\n        uniform float uTime;\n        attribute float size2;\n        varying float vAlpha;\n      "+e.vertexShader,e.vertexShader=e.vertexShader.replace("#include <begin_vertex>","\n        vec3 transformed = vec3(position);\n        transformed.z = -150. + mod(position.z + uTime, 300.);\n        vAlpha = smoothstep(-150.0, -125.0, transformed.z) * smoothstep(150.0, 125.0, transformed.z);\n      "),e.vertexShader=e.vertexShader.replace("gl_PointSize = size;","gl_PointSize = size2;"),e.fragmentShader="\n        varying float vAlpha;\n      "+e.fragmentShader,e.fragmentShader=e.fragmentShader.replace("#include <color_fragment>","\n        float alpha = vAlpha;\n        #ifndef USE_MAP\n          float dist = length(gl_PointCoord - 0.5);\n          if (dist > 0.5) discard;\n          alpha *= smoothstep(0.5, 0.0, dist);\n        #endif\n        diffuseColor.rgb *= vColor;\n        diffuseColor.a = alpha;\n      ")},this.particles=new p(this.geometry,this.material),this.add(this.particles)}loadMap(e){null===e?(this.material.map=null,this.material.needsUpdate=!0):(this.#C||(this.#C=new f),this.material.map=this.#C.load(e),this.material.needsUpdate=!0)}setSizes(e,t){const i=this.geometry.attributes.size2.array;for(let s=0;s<this.config.count;s++)i[s]=E(e,t);this.geometry.attributes.size2.needsUpdate=!0}setColors(e){const t=this.geometry.attributes.color.array,i=new v;for(let s=0;s<this.config.count;s++)i.set(e[Math.floor(Math.random()*e.length)]),i.toArray(t,3*s);this.geometry.attributes.color.needsUpdate=!0}update(e){this.#P.uTime.value+=e.delta*this.config.timeScale*10}}var U={uniforms:{tDiffuse:{value:null},center:{value:new o(.5,.5)},strength:{value:0}},vertexShader:"\n  varying vec2 vUv;\n    void main() {\n      vUv = uv;\n      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n    }\n  ",fragmentShader:"\n    uniform sampler2D tDiffuse;\n    uniform vec2 center;\n    uniform float strength;\n    varying vec2 vUv;\n\n    float random(vec3 scale, float seed) {\n      /* use the fragment position for a different seed per-pixel */\n      return fract(sin(dot(gl_FragCoord.xyz + seed, scale)) * 43758.5453 + seed);\n    }\n    \n    void main() {\n      vec4 color = vec4(0.0);\n      float total = 0.0;\n      vec2 toCenter = center - vUv;\n      \n      /* randomize the lookup values to hide the fixed number of samples */\n      float offset = random(vec3(12.9898, 78.233, 151.7182), 0.0);\n      \n      for (float t = 0.0; t <= 40.0; t++) {\n        float percent = (t + offset) / 40.0;\n        float weight = 4.0 * (percent - percent * percent);\n        vec4 texel = texture2D(tDiffuse, vUv + toCenter * percent * strength);\n\n        /* switch to pre-multiplied alpha to correctly blur transparent images */\n        texel.rgb *= texel.a;\n\n        color += texel * weight;\n        total += weight;\n      }\n\n      gl_FragColor = color / total;\n\n      /* switch back from pre-multiplied alpha */\n      gl_FragColor.rgb /= gl_FragColor.a + 0.00001;\n    }\n  "};const{lerp:_}=r;function I(e,t={}){const i=new y({canvas:e,size:"parent",rendererOptions:{antialias:!0}});i.camera.position.z=100,i.resize(),i.renderer.toneMapping=g;let s=1,n=1;const r=new z(i.scene,i.camera),a=new w(new o(i.size.width/2,i.size.height/2));a.radius=0,a.strength=.5,a.threshold=0;const h=new x(U),c=new b,d=new u(i.renderer);d.addPass(r),d.addPass(a),d.addPass(h),d.addPass(c),i.postprocessing=d;const l=new k(i,t);i.scene.add(l);const m=A({domElement:e});return i.onBeforeRender=e=>{const t=_(l.position.x,5*-m.nPosition.x,.02),i=_(l.position.y,5*-m.nPosition.y,.02);l.position.set(t,i,0),s+=.02*(n-s),h.uniforms.strength.value=.5*s/50,l.config.timeScale=s,l.update(e)},i.onAfterResize=e=>{d.setSize(e.width,e.height)},{three:i,bloomPass:a,particles:l,get velocity(){return s},set velocity(e){n=Math.min(Math.max(e,0),50)},dispose(){m.dispose(),i.dispose()}}}export{I as default};
